&T
[]T
(T, U)
func(T) U
owned T
weak T
mut T
T.U
T<U>

for i usize in 0 until length
for (i, j string) in x
for (a, b int32) in zip(array1, array2)

need type vs type distinction to avoid impl vs extend vs abstract -> actually don't care, just use
  the methods to distinguish
need cases to avoid open vs closed and to distinguish between embedding a single case vs all
put method inside type for convnience and consistency with cases
everything in module scope besides enum value cases, which are in type scope
extending a case type in the body of another type DOES export the cases of that type
abstracting a case type in the case part of another type only exports the cases included in 
  the new type




type UserId = uint64

type IntOrString cases {int32, string}

type File {Readable, Writeable}




pub module animals
import std.io

pub type Animal {
	pub name string
	pub age uint32
	pub func makeNoise(&this)
}

pub type Dog {
	Animal
	pub tag string
}

pub type Cat {
	Animal
	pub breed string
}

pub func makeNoise(dog &Dog) {
	printLine("woof")
}

pub func makeNoise(cat &Cat) {
	printLine("meow")
}

pub func main() {
	var pet mut &Animal = &Dog()
	makeNoise(pet)
	pet = &Cat()
	pet->makeNoise()
}




pub module shapes
import std.math

pub type Shape {
	pub color string
	pub func area(&this) float64
} cases {
	type Rectangle {pub width, height float64}
	type Triangle {pub base, height float64}
	type Circle {pub radius float64}
}

// data.txt
pub type MoreShapeData {
	shapes.Shape // embeds all fields
	pub extraData float64
} cases {
	Triangle // only embeds Triangle. if this wasnt here all cases would be included
}

// cases.txt
pub type MoreShapeCases {
	pub color string // only embeds color, not area().
} cases {
	shapes.Shape // embeds all cases.
	type Rhombus {}
}

pub func area(rectangle &Rectangle) {
	return rectangle.width*rectangle.height
}

pub func area(triangle &Triangle) {
	return 0.5*triangle.base*triangle.height
}

pub func area(circle &Circle) {
	return std.math.pi*circle.radius*circle.radius
}




pub module physics
import std.math
import std.operators

pub type Entity {
	pub pos, vel, acc Vector
	pub func collide(a, b &mut This)
} cases {
	type Circle {pub radius float64}
	type Mesh {pub vertices owned []Vector}
}

pub type Vector {
	std.operators.To<string>
	pub x, y, z float64
}

pub func collide(a, b &mut Circle) {}

pub func collide(a, b &mut Mesh) {}

pub func collide(a &mut Circle, b &mut Mesh) {}

pub func collide(a &mut Mesh, b &mut Circle) {}

pub func to<string>(vector &Vector) {
	return f"({vector.x}, {vector.y}, {vector.z})"
}




type Color {
	r, g, b uint8
} cases {
	type Rgb
	red = (255, 0, 0)
	green = (0, 255, 0)
	blue = (0, 0, 255)
}




// interface.txt
pub module interface

pub type Script {
	pub publicState int32
	pub func doSomething(&mut this)
}


// myscript.txt -> myscript.so
pub module myScript
import std.io
import interface

pub type MyScript {
	interace.Script
}

pub func doSomething(myScript &mut MyScript) {
	std.io.printLine("script loaded successfully")
}

// The entry point for the script.
pub func load() MyScript {
	return MyScript()
}


pub module program
import std.objects
import interface

pub func main() {
	var script &Script = std.objects.load<&Script>("myscript.so")
	doSomething(script)
}




pub func main() {
	var name mut string = "default"
	var age mut int32 = 4
	var required bool
	addOptionalFlags(&name, &age)
	addRequiredFlag(&bool)
	if var error = parseFlags() {
		printLine(error.message)
		return
	}
}
